---
VIP: 200
Title: Implementation of SURFACE BFT Protocol
Author: Ziheng Zhou (peter.zhou@vechain.com) and Zhijie Ren (zhijie.ren@vechain.com)
Category: Core
Status: Draft
CreatedAt: 2019-08-09
---

# Overview

This proposal outlines the implementation of the Byzantine Fault Tolerance (BFT) protocol described in [1]. The goal is to allow blocks of the Thor blockchain to reach BFT finality.

# Specification

## Block

The basic idea is to allow blocks to carry extra finality-related messages so that nodes can update their BFT states once they receive the blocks and reach block finality. There are four messages, each of which is a block id, representing the new-view `nv`, prepare `pp`, pre-commit `pc` and commit `cm` messages, respectively.

```go
type headerBody struct { 
    ...
    nv  thor.Byte32
    pp  thor.Byte32
    pc  thor.Byte32
    cm  thor.Byte32
}
```

## Local Finality State

Each node `u` maintains its own local finality state that can be defined as:

```go
type fState struct {
    nv  thor.Byte32
    pp  thor.Byte32
    pc  thor.Byte32
    cm  thor.Byte32
    fn  thor.Byte32
}
```

where `fn` refers the latest finalized block.

## View

A view is defined as a chain of blocks such that

* They start with block `b0`,
* Every block's `nv` message equals the id of `b0`.

```go
type View interface {
    // Add a new block in the view
    add(b *block.Block) error

    // Get the id of the first block
    id() thor.Byte32

    // Method nv checks whether the view contains at least 2f+1 non-duplicate leaders and backers.
    nv() bool

    // Method nv checks whether the view contains at least 2f+1 non-duplicate leaders and backers. It returns false if no. Otherwise, it proceeds to check whether there is any pc value that refers to a block that is on another branch. If yes, it returns true or false otherwise.
    nv1() bool

    // Method pp checks whether there is a pp value such that the number of non-duplicate leaders and backers of the blocks that contain the pp value is equal or larger than 2f+1. It returns (false, 0) if no. Otherwise, it proceeds to check whether there is any pc value that refers to a block that is on another branch. If yes, it returns (true, pp) or (false, 0) otherwise.
    pp() (bool, thor.Byte32)

    // Method pc checks whether there is a pc value such that the number of non-duplicate leaders and backers of the blocks that contain the pc value is equal or larger than 2f+1.
    pc() bool

    // Method npc returns the number of blocks in the view s.t. pc == v
    npc(v thor.Byte32) uint
}
```

A view `v0` is called *ready to pre-commit* (RTPC) if it satisfies the following conditions:

Let `(f, pp) = v0.pp()`.

1. `f == true`
2. For any view `v1` after `v0`, i.e., `Number(v1.id()) > Number(v0.id())`, `v1.npc(pp) > 0`.

## Finality State Update

Node `u` maintains the following local variables:

```go
// Local finality state
var s fState

// Ids of the blocks not yet finalized locally, but having been committed by other nodes
var committedBlocks map[thor.Byte32][]thor.Address

// Storage of the current RTPC view
var curRTPC *View
```

# References

[1] Ren, Z. and Z. Zhou (2020) SURFACE: A Practical Blockchain Consensus Algorithm for Real-World Networks, arXiv:2002.07565.