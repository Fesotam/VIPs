---
VIP: 200
Title: Implementation of SURFACE BFT Protocol
Author: Ziheng Zhou (peter.zhou@vechain.com) and Zhijie Ren (zhijie.ren@vechain.com)
Category: Core
Status: Draft
CreatedAt: 2019-08-09
---

# Overview

This proposal outlines the implementation of the Byzantine Fault Tolerance (BFT) protocol described in [1]. The goal is to allow blocks of the Thor blockchain to reach BFT finality.

# Specification

## Block

The basic idea is to allow blocks to carry extra finality-related messages so that nodes can update their BFT states once they receive the blocks and reach block finality. There are four messages, each of which is a block id, representing the new-view `nv`, prepare `pp`, pre-commit `pc` and commit `cm` messages, respectively.

```go
type headerBody struct { 
    ...
    nv  thor.Byte32
    pp  thor.Byte32
    pc  thor.Byte32
    cm  thor.Byte32
}

// Get messages
func (h *Header) NV() thor.Byte32
func (h *Header) PP() thor.Byte32
func (h *Header) PC() thor.Byte32
func (h *Header) CM() thor.Byte32

// Get addresses of the leaders and backers
func (h *Header) GetLeaderAndBackers() []*thor.Address
```

## Local Finality State

Each node `u` maintains its own local finality state that can be defined as:

```go
type fState struct {
    nv  thor.Byte32
    pp  thor.Byte32
    pc  thor.Byte32
    cm  thor.Byte32
    fn  thor.Byte32
}
```

where `fn` refers the latest finalized block.

## View

A view is defined as a chain of blocks such that

* They start with block `b0`,
* Every block's `nv` message equals the id of `b0`.

```go
type view interface {
    // Add a new block in the view
    add(b *block.Block) error

    // Get the id of the first block
    id() thor.Byte32

    // Method nv checks whether the view contains at least 2f+1 non-duplicate leaders and backers.
    nv() bool

    // Method nv checks whether the view contains at least 2f+1 non-duplicate leaders and backers. It returns false if no. Otherwise, it proceeds to check whether there is any pc value that refers to a block that is on another branch. If yes, it returns true or false otherwise.
    nv1() bool

    // Method pp checks whether there is a pp value such that the number of non-duplicate leaders and backers of the blocks that contain the pp value is equal or larger than 2f+1. It returns (false, 0) if no. Otherwise, it proceeds to check whether there is any pc value that refers to a block that is on another branch. If yes, it returns (true, pp) or (false, 0) otherwise.
    pp() (bool, thor.Byte32)

    // Method pc checks whether there is a pc value such that the number of non-duplicate leaders and backers of the blocks that contain the pc value is equal or larger than 2f+1.
    pc() bool

    // Method npc returns the number of blocks in the view s.t. pc == v
    npc(v thor.Byte32) uint
}

// Create a new view
func NewVieW(b *block.Block) *View
```

A view `v0` is called *ready to pre-commit* (RTPC) if it satisfies the following conditions:

Let `(f, pp) = v0.pp()`.

1. `f == true`
2. For any view `v1` after `v0`, i.e., `Number(v1.id()) > Number(v0.id())`, `v1.npc(pp) > 0`.

## Finality State Update

Node `u` maintains the following local variables:

```go
// Local finality state
var s fState

// Info of blocks committed by other nodes, but not yet committed locally
type committedBlockInfo interface {
    // Method update updates the info given the input new block and id of the latest block locally committed. It discard any block id s.t. Number(id) < Number(cm) and return the id of a block if the block is committed by no less than f+1 different nodes.
    update(b *block.Block, cm thor.Byte32) thor.Byte32
}
var info committedBlockInfo

// Current view
var curView *view

// Current RTPC view
var curRTPC *view
```

Given a new block `var b *block.Block`, node `u` updates its finality state and local variables as follows:

```go
// Try to add b to the current view. If failure, start a new view
if !curView.add(b) {
    curView = NewView(b)
}

/////////////////////////////
// update s.cm
/////////////////////////////
if curView.npc(f.pc) >= 2f+1 {
    f.cm = curView.id()
    f.pc = thor.Byte32{}
}
if id := info.update(b, f.cm); id != thor.Byte32{} {
    f.cm = id
}
if Number(s.fn) < Number(s.cm) {
    f.fn = f.cm
}

/////////////////////////////
// update s.pc
/////////////////////////////
```

# References

[1] Ren, Z. and Z. Zhou (2020) SURFACE: A Practical Blockchain Consensus Algorithm for Real-World Networks, arXiv:2002.07565.