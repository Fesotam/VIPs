---
VIP: 200
Title: Implementation of SURFACE BFT Protocol
Author: Ziheng Zhou (peter.zhou@vechain.com) and Zhijie Ren (zhijie.ren@vechain.com)
Category: Core
Status: Draft
CreatedAt: 2019-08-09
---

# Overview

This proposal outlines the implementation of the Byzantine Fault Tolerance (BFT) protocol described in [1]. The goal is to allow blocks of the Thor blockchain to reach BFT finality.

# Specification

## Block

The basic idea is to allow blocks to carry extra finality-related messages so that nodes can update their BFT states once they receive the blocks and reach block finality. There are four messages, each of which is a block id, representing the new-view `nv`, prepare `pp`, pre-commit `pc` and commit `cm` messages, respectively.

```go
type headerBody struct { 
    ...
    nv  *block.Header
    pp  *block.Header
    pc  *block.Header
    cm  *block.Header
}

// Get messages
func (h *Header) NV() *block.Header
func (h *Header) PP() *block.Header
func (h *Header) PC() *block.Header
func (h *Header) CM() *block.Header
```

## Local Finality State

Each node `u` maintains its own local finality state that can be defined as:

```go
type fState struct {
    nv  *block.Header
    pp  *block.Header
    pc  *block.Header
    cm  *block.Header
    fn  *block.Header
}
```

where `fn` refers the latest finalized block.

## View

A view is defined as a chain of blocks such that

* They start with block `b0`,
* Every block's `nv` message points to `b0`.

```go
type view interface {
    // Try to add block b in the current view if b's nv refers to the first block of this view. Otherwise, if b's nv points to itself, start a new view. Return true if b can be added to the current view or false otherwise.
    update(b *block.Header)

    // Get the id of the first block
    first() *block.Header

    // Method nv checks whether the view contains at least 2f+1 non-duplicate leaders and backers.
    nv() bool

    // Method nv checks whether the view contains at least 2f+1 non-duplicate leaders and backers. It returns false if no. Otherwise, it proceeds to check whether there is no pc value that refers to a block that is on another branch. If yes, it returns true or false otherwise.
    nv1() *block.Header

    // Method pp checks whether there is a pp value such that the number of non-duplicate leaders and backers of the blocks that contain the pp value is equal or larger than 2f+1. It returns nil if no. Otherwise, it proceeds to check whether there is no pc value that refers to a block that is on another branch. If yes, it returns the pp value or nil otherwise.
    pp() *block.Header

    // Method pc checks whether there is a pc value sch that the number of non-duplicate leaders and backers of the blocks that contain the pc value is equal or larger than 2f+1. It returns the pc value if yes or nil otherwise.
    pc() *block.Header

    // Method npc returns the number of blocks in the view s.t. pc == v
    npc(b *block.Header) uint
}
```

Block `b` is called *ready to pre-commit* (RTPC) if there exists a view `v0` such that the following conditions hold:

1. `v0.pp.ID() == b.ID()`
2. For any view `v1` newer than `v0`, if `v1.nv() == true` then 
 * `v1.first(Timestamp).Round(Timestamp) > v0.first(Timestamp).Round(Timestamp)`
 * `v1.npc(b) > 0`.

```go
// rtpc maintains the RTPC view. The view is not necessarily on the canonical view. It is guaranteed that there would be only one RTPC view at one time for any honest node.
type RTPC interface {
    // Update the latest RTPC view. 
    // 
    // Let v := repo.GetView(b.NV())
    //
    // If b is the newest block of the canonical chain and v.pp() != nil, then set v as the RTPC view
    // 
    // If b is not on the cannocial chain and v.pp() != nil. Let v' be the current RTPC view. If v' == nil || v is newer than v', check Condition 2 and if satisfied, set v as the RTPC view.
    update(b *block.Header)

    get() *view
}
```

## Finality State Update

Define
```go
// Get the view starting from b.NV() to b
// Error: blocks before b in the view already contain at least 2f+1 non-duplicate leaders and backers  
func (r *Repository) GetView(b *block.Header) (*view, error)

// Check whether b1 and b2 are on two different branches
func (r *Repository) IfConflict(b1, b2 *thor.Byte32) bool 
```

Each node maintains the following local variables:

```go
// Local finality state
var s fState

// Info of blocks committed by other nodes, but not yet committed locally
type committedBlockInfo interface {
    // Method update updates the info given the input new block and the latest locally-committed block. It discard any block id s.t. Number(id) < Number(cm) and return the id of a block if the block is committed by no less than f+1 different nodes.
    update(b *block.Header, cm *block.Header) *block.Header
}
var cmInfo committedBlockInfo

// RTPC view
var rtpc *RTPC

// Last block signed either as the leader or a backer by the node
var lastSignedBlock *block.Header

// Whether the signed pc is nullified by 2f+1 nv messages with no pc
var pcsigexpired *boolean

// Previously handled last block of the cannoical chain.
var prevBestBlock *block.Header
```

Given a latest received valid block (not necessarily on the canonical chain)
```go
var b *block.Header
```

Check whether the signed pc is nullified so that node can pre-commit other blocks again
```go
if v.nv() && v.npc(lastSignedBlock.PC()) == 0 {
    pcsigexpired = true
}
```
the node updates its finality state and local variables as follows:

```go
isOnCanonicalChain := b.ID() == repo.BestBlock.ID()
v, err := repo.GetView(b)

/////////////////////////////
// update s.cm
/////////////////////////////
if pc := v.pc(); pc != nil {
    f.cm = pc
    f.pc = nil
}
if id := cmInfo.update(b, f.cm); !id.IsZero() {
    f.cm = id
}
if s.fn.Timestamp() < s.cm.Timestamp() {
    f.fn = f.cm
}

/////////////////////////////
// update s.pc
/////////////////////////////
rtpc.update(b)
if pc := rtpc.get().pp(); pc != nil && !repo.IsConflict(pc, lastSignedBlock.PC()) {
    s.pc = pc
} else if repo.IsConflict(pc, lastSignedBlock.PC()) && pcsigexpired {
    s.pc = pc
}
/////////////////////////////
// unlock s.pc
/////////////////////////////
if s.pc != rtpc.get().pp() {
    s.pc = nil
}

/////////////////////////////
// update s.pp
/////////////////////////////
if pp := v.nv1(); isOnCanonicalChain && pp != nil {
    s.pp = pp
}

/////////////////////////////
// update s.nv
/////////////////////////////
if isOnCanonicalChain {
    if b.NV().Timestamp() > s.nv.Timestamp() {
        s.nv = b.NV()
    } else if s.nv == nil || b.ParentID() != lastBestBlock.ID() || err != nil || v.nv() {
        s.nv = b
    }
}

/////////////////////////////
// unlock s.pc
/////////////////////////////
if repo.IsConflict(s.nv.ID(), s.pp.ID()) {
    s.pp = nil
}
```

# References

[1] Ren, Z. and Z. Zhou (2020) SURFACE: A Practical Blockchain Consensus Algorithm for Real-World Networks, arXiv:2002.07565.
